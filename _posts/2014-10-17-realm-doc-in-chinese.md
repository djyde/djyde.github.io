---
layout: post
title: Realm 中文文档
date: 2014-10-17
tag: android
---

[官方文档](http://realm.io/docs/java/)

**开始**
------
**请注意我们当前不支持除 Android 环境以外的 Java 环境使用 Realm**

环境要求
===
* Android Studio (>=0.8.6)
* 较新的 Android SDK 版本
* JDK（ >=7 ）

*我们支持 API 9 以上的 Android版本（Android 2.3以上）*

安装
===
你有两种安装方法可以选择：

#####Maven
1. 确定你的项目支持 jcenter 依赖（默认为最新版本的 Android Gradle 插件）
2. 在 dependencies 中增加 `compile 'io.realm:realm-android:0.71.0'`
3. 在 Android Studio 菜单中选择：Tools->Android->Sync Project with Gradle Files

#####使用包
1. [下载](http://static.realm.io/downloads/java/latest)最新包并解压
2. 在 Android Studio 创建一个新的项目
3. 复制 `realm-版本.jar` 文件夹到 `app/libs`
4. 在 Android Studio 菜单中选择：Tools->Android->Sync Project with Gradle Files

Realm Browser
===
**目前仅支持Mac OS X。Windows和Linux版本正在开发中。**

![](http://realm.io/assets/docs/browser.png)

我们提供一个独立的应用来读写`.realm`数据库。

你可以在[Cocoa release zip](http://static.realm.io/downloads/cocoa/latest)的`browser/`文件夹中找到

你可以在**Tools>Generate demo database**中生成一个用以测试的数据库。

实例
===
在根目录中我们提供了几个examples来帮助你熟悉运用 Realm。你只需要在 Android Studio 中导入运行即可。

`RelamIntroExample`包含了一个使用当前API的简单实例，在项目中你只能从Log中看到看到输出。

`RealmGridViewExample`是一个app，用来展示如何用Realm渲染GridView。

`RealmConcurrencyExample`是一个简单的app用以展示在多线程中使用Realm，

获得帮助
===
* 订阅[community newsletter](http://eepurl.com/VEKCn)定期获取使用Realm的一些技巧和教程。
* 我们也能通过你们在[google groups](https://groups.google.com/forum/#!forum/realm-java)的问题反馈来完善 Realm for Android。
* 除了google groups，我们还建议你通过[Github](https://github.com/realm/realm-java)提交问题。

**模型**
---
Realm 数据模型通过类似 [Java Bean](http://zh.wikipedia.org/zh/JavaBeans) 的模式实现，然后继承`RealmObject`即可。

{% highlight java %}
public class User extends RealmObject {

    private String          name;
    private int             age;

    @Ignore
    private int             sessionId;

    // Standard getters & setters generated by your IDE…
    public String getName() { return name; }
    public void   setName(String name) { this.name = name; }
    public int    getAge() { return age; }
    public void   setAge(int age) { this.age = age; }
    public int    getSessionId() { return sessionId; }
    public void   setSessionId(int dontPersist) { this.sessionId = sessionId; }
}
{% endhighlight %}

注意，getters和setters会被 RealmObjects 在后台重写，所以任何在getters和setters里自己写的逻辑是不会被执行的。

RealmObjects依赖一个[Realm](#realms)，所以一定要用`realm.createObject()`来从Realm中实例化它。

数据类型
====
Realm支持这几种数据类型：`boolean`,`short`,`int`,`long`,`float`,`double`,`string`,`Date`和`byte[]`。再者，`RealmObject`的子类和`RealmList<? extends RealmObject>`支持多模型关联。（原句：subclasses of RealmObject and RealmList<? extends RealmObject> are supported to model relationships.）

“忽略”
====
被`@Ignore`注解的数据意味着它不会长期存在于内存中。
（原句：The annotation `@Ignore` implies that a field should not be persisted to disk.）

索引
====
`@Index`注解会增加一个索引数据，这会导致插入速度变慢，并且数据容量会增加，但好处是在查询的时候速度更快些。所以请慎重考虑是否必要引入索引。目前仅string能被索引（其它数据类型的索引会在下个版本中支持）。

插入
----
读数据操作是隐式的，但所有写的操作（增加，修改，移除）都必须包含在`write transactions`中以确保线程安全：

{% highlight java %}
// 获得一个Realm实例
Realm realm = Realm.getInstance(this);

realm.beginTransaction();

//... 在这里执行增添或更新操作 ...

realm.commitTransaction();
{% endhighlight %}

数据对象需要通过Realm来实例化：

{% highlight java %}
// 获得一个Realm实例
Realm realm = Realm.getInstance(this);

realm.beginTransaction();
User user = realm.createObject(User.class); // 创建新对象
user.setName("John");
user.setEmail("john@corporation.com");
realm.commitTransaction();
{% endhighlight %}

（未翻译）Please note that writes block each other, and will block the thread they are made on if other writes are in progress. Thanks to Realm’s MVCC architecture, reads are not blocked while a write transaction is open! This means that unless you need to make simultaneous writes from many threads at once, you should favor larger write transactions that do more work over many fine-grained write transactions. When you commit a write transaction to a Realm, all other instances of that Realm will be notified, and the read implicit transactions will refresh your Realm objects automatically.

查询
---
Realm的查询引擎使用 [Fluent interface](https://en.wikipedia.org/wiki/Fluent_interface) 来执行多条件查询：
{% highlight java %}
// 执行查找所有user的查询:
RealmQuery<User> query = realm.where(User.class);

// 定义查询条件:
query.equalTo("name", "John");
query.or().equalTo("name", "Peter");

// 执行查询:
RealmResults<User> result1 = query.findAll();

// 或者同时进行上述操作 (通过 "Fluent interface"):
RealmResults<User> result2 = realm.where(User.class)
                                  .equalTo("name", "John")
                                  .or()
                                  .equalTo("name", "Peter")
                                  .findAll();
{% endhighlight %}

查询返回一个`RealmResults`，包含名叫 John 和 Peter 的两个User对象。你可以使用这些匹配到的对象来做你要做的事务。

条件
===
Realm 支持以下查询条件：

* `greaterThan()`,`lessThan()`,`greateThanOrEqualTo()`
* `equalTo()`&`notEqualTo()`
* `contains()`,`beiginsWith()`&`endsWith()`

并非所有条件都适用于所有数据类型，具体请看 [RealmQuery API](http://realm.io/docs/java/0.71.0/api/io/realm/RealmQuery.html) 。

逻辑操作
===
每个查询条件都会被被隐式地被“`逻辑和(&)`”组合在一起，而“`逻辑或(or)`”需要显式地去执行`or()`。

你也可以将查询条件组合在一起，使用`beginGroup()`（相当于左括号）和`endGroup()`（相当于右括号）：

{% highlight java %}
RealmResults<User> r = realm.where(User.class)
	                        .greaterThan("age", 10)  //隐式的逻辑和（&）
	                        .beginGroup()
	                        	.equalTo("name", "Peter")
	                            .or()
	                            .contains("name", "Jo")
	                        .endGroup()
	                        .findAll();
{% endhighlight %}

分类、筛选
====
当你执行完查询获得结果后，可以对它进行分类和筛选：
{% highlight java %}
RealmResults<User> result = realm.where(User.class).findAll();
RealmResults<User> sortedAscending  = result.sort("age");
RealmResults<User> sortedDescending = result.sort("age", RealmResults.SORT_ORDER_DECENDING);
{% endhighlight %}

链式查询
===
你也可以直接在查询后进行分类筛选：
{% highlight java %}
RealmResults<User> teenagers = Realm.where(User.class).between("age", 13, 20).findAll();
RealmResults<User> firstJohn = teenagers.where().equalTo("name", "John").findFirst();
{% endhighlight %}

查询结果运算
===
`RealmResult`自带一些运算方法：
{% highlight java %}
long   sum     = result.sum("age").longValue(); //加法
long   min     = result.min("age").longValue(); //最小值
long   max     = result.max("age").longValue(); //最大值
double average = result.average("age"); //平均数

long   matches = result.size();
{% endhighlight %}

遍历
===
遍历`RealmResults`的方法可以这样：
{% highlight java %}
for (User u : result) {
    // ... do something with the object ...
}
{% endhighlight %}

或者使用for循环：
{% highlight java %}
for (int i = 0; i < result.size(); i++) {
    User u = result.get(i);
    // ... do something with the object ...
}
{% endhighlight %}

删除
===
你可以从查询结果中删除数据
{% highlight java %}
// 所有的数据改变需要被包含在 Transaction 里
realm.beginTransaction();

// 删除一条数据
result.remove(0);
result.removeLast();

// 删除所有匹配到的数据
result.clear();

realm.commitTransaction();
{% endhighlight %}

<h2 id="realms">Realm(s)</h2>

Realm(s)是们对数据库的称谓：它包含多个不同的对象，在储存器里对应着一个文件。

默认的Realm
====
你可能已经意识到，我们一般通过`Realm.getInstance(this)`初始化一个realm变量。这个只有一个参数的方法为你的线程返回一个实例，它对应了在你的app的文件根目录中的一个`default.realm`文件。

自定义的Realm(s)
====
当你需要不同的数据库来储存不同数据的时候，有必要使用多个realms：
{% highlight java %}
Realm moviesrealm = Realm.getInstance(this, "allmymovies.realm");
{% endhighlight %}

事件监听
----
如果你正在一个后台线程中增加数据，你的UI和其它线程可以通过一个监听器获取Realm的变化：
{% highlight java %}
realm.addChangeListener(new RealmChangeListener() {
    @Override
    public void onChange() {
        // ... do something with the updates (UI, etc.) ...
    }
});
{% endhighlight %}

如果有需要，你可以很方便地关掉所有监听器：
{% highlight java %}
realm.removeAllChangeListeners();
{% endhighlight %}

数据模型变化
----
随着时间的推动，数据模型变化是常有的事。从一开始在Realm中定义了数据对象后，如果需要改变它，只需要改变RealmObject子类即可。

如果在储存器中没有旧的数据，那么你只要修改你的代码就能改变数据对象。如果有，那么在执行查询时会因为不匹配而报错。

所以我们提供了方法给你去更新你的旧数据对象，详情请看我们的实例[migrationSample app](https://github.com/realm/realm-java/tree/master/examples/migrationExample)

下一步
----
你可以查看我们的[example](https://github.com/realm/realm-java/tree/master/examples)中的实例（我们会陆续提供更多samples）。

Happy hacking!你可以在[realm-java](https://groups.google.com/d/forum/realm-java)里和真人开发者交流。

FAQ
----
**我应该在产品级应用中使用Realm吗？**

Realm从2012年开始就已经被用于商业产品。

通过交流反馈你还能推动我们的bug修复和发展。

**我需要向Realm支付费用吗？**

不，Realm for Android 完全免费，在商业项目使用它也不需要收费。

**那你们怎么创造收入呢？**

（这个还是放原句好）We’re actually already generating revenue selling enterprise products and services around our technology. If you need more than what is currently in our releases or in [realm-java](http://github.com/realm/realm-java), we’re always happy to chat [by email](http://realm.io/docs/java/0.71.0/info@realm.io). Otherwise, we are committed to developing realm-java in the open, and to keep it free and open-source under the Apache 2.0 license.

**源码里面引用的“tightdb”和"core"是什么？**

TightDB是我们C++存储引擎内核的旧名称，内核目前还没开源，但是我们已经有这个计划，只要我们有时间梳理一下、改改名字，等最后敲定后，就会开放源代码，并且同样使用 Apache 2.0 协议。