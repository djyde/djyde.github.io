<!DOCTYPE html><html data-saber-ssr><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta data-saber-head="ssr" name="generator" content="Saber v0.11.2"> <title>未来属于声明式编程 - Randy&#x27;s Blog</title> <link data-saber-head="ssr" rel="stylesheet" href="//ppp.djyde.com/css?family=Noto+Serif+SC"><style data-vue-ssr-id="d798a246:0 5130aa06:0 a252aa48:0">/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:rgba(0,0,0,0)}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}body{font-family:"Noto Serif SC",Lusitana,serif;line-height:1.4rem}blockquote{margin:0;padding:0 0 0 1.5rem;border-left:.5rem solid #ccc}a{color:#333;-webkit-transition:all .2s;transition:all .2s;text-decoration:none}a:hover{color:#000}a.big{padding-left:.25rem;padding-right:.25rem;border-bottom:.25rem solid #1a1a1a}a.big:hover{background-color:#000;color:#fff}.twitter{color:#0c9df2}.zhihu{color:#0767c8}.weibo{color:#e80025}.github{color:#333}.medium{color:#00ab6b}.email{color:#4285f4}.telegram{color:#179cde}.hr{height:0;font-size:1rem;line-height:0;text-transform:uppercase;text-align:center;border-bottom:1px solid #ccc;margin-top:2rem;margin-bottom:2rem;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.hr span{background-color:#fff;padding-left:.5em;padding-right:.5em;color:#ccc}li{margin-bottom:.5rem}h1,h2,h3,h4,h5,h6{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,PingFang SC,Hiragino Sans GB,Microsoft Yahei,sans-serif}#footer{margin-top:2em;padding:1em;background-color:#fafafa;text-align:center}#footer,#footer a{color:#c0c5ce}
code[class*=language-][data-v-48809fbe],pre[class*=language-][data-v-48809fbe]{color:#f8f8f2;background:none;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-][data-v-48809fbe]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-][data-v-48809fbe],pre[class*=language-][data-v-48809fbe]{background:#282a36}:not(pre)>code[class*=language-][data-v-48809fbe]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata[data-v-48809fbe],.token.comment[data-v-48809fbe],.token.doctype[data-v-48809fbe],.token.prolog[data-v-48809fbe]{color:#6272a4}.token.punctuation[data-v-48809fbe]{color:#f8f8f2}.namespace[data-v-48809fbe]{opacity:.7}.token.constant[data-v-48809fbe],.token.deleted[data-v-48809fbe],.token.property[data-v-48809fbe],.token.symbol[data-v-48809fbe],.token.tag[data-v-48809fbe]{color:#ff79c6}.token.boolean[data-v-48809fbe],.token.number[data-v-48809fbe]{color:#bd93f9}.token.attr-name[data-v-48809fbe],.token.builtin[data-v-48809fbe],.token.char[data-v-48809fbe],.token.inserted[data-v-48809fbe],.token.selector[data-v-48809fbe],.token.string[data-v-48809fbe]{color:#50fa7b}.language-css .token.string[data-v-48809fbe],.style .token.string[data-v-48809fbe],.token.entity[data-v-48809fbe],.token.operator[data-v-48809fbe],.token.url[data-v-48809fbe],.token.variable[data-v-48809fbe]{color:#f8f8f2}.token.atrule[data-v-48809fbe],.token.attr-value[data-v-48809fbe],.token.class-name[data-v-48809fbe],.token.function[data-v-48809fbe]{color:#f1fa8c}.token.keyword[data-v-48809fbe]{color:#8be9fd}.token.important[data-v-48809fbe],.token.regex[data-v-48809fbe]{color:#ffb86c}.token.bold[data-v-48809fbe],.token.important[data-v-48809fbe]{font-weight:700}.token.italic[data-v-48809fbe]{font-style:italic}.token.entity[data-v-48809fbe]{cursor:help}.saber-highlight code[data-v-48809fbe]{font-size:.5rem}.post-footer[data-v-48809fbe]{padding-top:2rem;text-align:center;color:#65737e}.post-footer p[data-v-48809fbe]{margin-top:.5em;margin-bottom:.5em}.bmc[data-v-48809fbe]{max-width:30%!important}@media (min-width:320px) and (max-width:479px){.bmc[data-v-48809fbe]{max-width:100%!important}}.cover[data-v-48809fbe]{padding-bottom:40%}@media (min-width:320px) and (max-width:479px){.cover[data-v-48809fbe]{padding-bottom:75%}}.cover[data-v-48809fbe]{background-size:cover;background-position:50%}.post[data-v-48809fbe]{margin-top:4rem}.post h1[data-v-48809fbe],.post h2[data-v-48809fbe],.post h3[data-v-48809fbe],.post h4[data-v-48809fbe],.post h5[data-v-48809fbe],.post h6[data-v-48809fbe]{margin:2rem 0 0}.post strong[data-v-48809fbe]{background-color:#e6e6e6;color:#000;padding-left:.25rem;padding-right:.25rem}.post .title[data-v-48809fbe]{line-height:2.5rem;margin-bottom:1rem}.post .date[data-v-48809fbe]{color:grey}@media (min-width:1025px){.post[data-v-48809fbe]{width:960px;margin:0 auto}}@media (min-width:320px) and (max-width:479px){.post[data-v-48809fbe]{padding-left:5%;padding-right:5%}.post img[data-v-48809fbe]{width:100%}}@media (min-width:481px) and (max-width:1024px){.post[data-v-48809fbe]{padding-left:5%;padding-right:5%}}.post .content img[data-v-48809fbe]{max-width:100%;display:block;margin:0 auto}@media (min-width:481px) and (max-width:1024px){.post .content img[data-v-48809fbe]{width:100%}}@media (min-width:320px) and (max-width:479px){.post .content img[data-v-48809fbe]{width:100%}}.post .content p[data-v-48809fbe]{line-height:1.8rem}.post .content a[data-v-48809fbe]{padding-left:.25rem;padding-right:.25rem;border-bottom:.25rem solid #1a1a1a}.post .content a[data-v-48809fbe]:hover{background-color:#000;color:#fff}.footer[data-v-48809fbe]{text-align:center}
nav[data-v-634644b4]{background-color:#000}nav .logo[data-v-634644b4]{padding-left:1rem;margin-right:2rem;display:inline-block}nav .logo a[data-v-634644b4]{font-weight:700;color:#fff}nav .nav-item[data-v-634644b4]{display:inline-block}nav .nav-item a[data-v-634644b4]{display:block;color:#fff;padding:.5rem}nav .nav-item a[data-v-634644b4]:hover{color:#000;background-color:#fff}</style>  </head><body><div id="_saber" data-server-rendered="true"><div><div data-v-48809fbe><nav data-v-634644b4 data-v-48809fbe><div class="logo" data-v-634644b4><a href="/" class="router-link-active" data-v-634644b4>Randy's Blog</a></div> <div class="nav-item" data-v-634644b4><a href="/readings" data-v-634644b4>Readings</a></div></nav> <!----> <div class="post" data-v-48809fbe><h1 class="title" data-v-48809fbe>未来属于声明式编程</h1> <div class="date" data-v-48809fbe>July 18, 2019</div> <div class="content" data-v-48809fbe><p data-v-48809fbe><a rel="noopener noreferrer" target="_blank" href="https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B?oldformat=true" data-v-48809fbe>声明式编程</a> （Declarative Programming）是一种编程范式。现实世界中，我们大部分编码都是命令式的。</p> <p data-v-48809fbe>举个最常见的例子，对于用 JavaScript 来构建 UI, React 是声明式的。</p> <div class="saber-highlight" data-lang="js" data-v-48809fbe><pre class="saber-highlight-code language-js" data-v-48809fbe><code class="language-js" data-v-48809fbe><span class="token comment" data-v-48809fbe>// 普通的 DOM API 构建 UI</span>

<span class="token keyword" data-v-48809fbe>const</span> div <span class="token operator" data-v-48809fbe>=</span> document<span class="token punctuation" data-v-48809fbe>.</span><span class="token function" data-v-48809fbe>createElement</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token string" data-v-48809fbe>'div'</span><span class="token punctuation" data-v-48809fbe>)</span>
<span class="token keyword" data-v-48809fbe>const</span> p <span class="token operator" data-v-48809fbe>=</span> document<span class="token punctuation" data-v-48809fbe>.</span><span class="token function" data-v-48809fbe>createElement</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token string" data-v-48809fbe>'p'</span><span class="token punctuation" data-v-48809fbe>)</span>
p<span class="token punctuation" data-v-48809fbe>.</span>textContent <span class="token operator" data-v-48809fbe>=</span> <span class="token string" data-v-48809fbe>'hello world'</span>
<span class="token keyword" data-v-48809fbe>const</span> <span class="token constant" data-v-48809fbe>UI</span> <span class="token operator" data-v-48809fbe>=</span> div<span class="token punctuation" data-v-48809fbe>.</span><span class="token function" data-v-48809fbe>append</span><span class="token punctuation" data-v-48809fbe>(</span>p<span class="token punctuation" data-v-48809fbe>)</span></code></pre></div><div class="saber-highlight" data-lang="js" data-v-48809fbe><pre class="saber-highlight-code language-js" data-v-48809fbe><code class="language-js" data-v-48809fbe><span class="token comment" data-v-48809fbe>// React 构建 UI</span>
<span class="token keyword" data-v-48809fbe>const</span> h <span class="token operator" data-v-48809fbe>=</span> React<span class="token punctuation" data-v-48809fbe>.</span>craeteElement
<span class="token keyword" data-v-48809fbe>const</span> <span class="token constant" data-v-48809fbe>UI</span> <span class="token operator" data-v-48809fbe>=</span> <span class="token function" data-v-48809fbe>h</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token string" data-v-48809fbe>'div'</span><span class="token punctuation" data-v-48809fbe>,</span> <span class="token keyword" data-v-48809fbe>null</span><span class="token punctuation" data-v-48809fbe>,</span> <span class="token function" data-v-48809fbe>h</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token string" data-v-48809fbe>'p'</span><span class="token punctuation" data-v-48809fbe>,</span> <span class="token keyword" data-v-48809fbe>null</span><span class="token punctuation" data-v-48809fbe>,</span> <span class="token string" data-v-48809fbe>'hello world'</span><span class="token punctuation" data-v-48809fbe>)</span><span class="token punctuation" data-v-48809fbe>)</span></code></pre></div><p data-v-48809fbe>所有的 DSL (HTML, XML, SQL) 都是声明式的，你写出一条 SQL 语句，只是为了告诉数据库你要什么，然后数据库就会给你对应的数据，而不是通过数据库的 API 去取。</p> <div class="saber-highlight" data-lang="sql" data-v-48809fbe><pre class="saber-highlight-code language-sql" data-v-48809fbe><code class="language-sql" data-v-48809fbe><span class="token keyword" data-v-48809fbe>SELECT</span> <span class="token operator" data-v-48809fbe>*</span> <span class="token keyword" data-v-48809fbe>FROM</span> Products <span class="token keyword" data-v-48809fbe>WHERE</span> name<span class="token operator" data-v-48809fbe>=</span><span class="token string" data-v-48809fbe>'Alipay'</span></code></pre></div><p data-v-48809fbe>Apple 在今年 (2019 年) 也推出了 Swift UI, 在 WWDC 的 Swift UI 相关的 Session 里也<a rel="noopener noreferrer" target="_blank" href="https://developer.apple.com/videos/play/wwdc2019/216/" data-v-48809fbe>多次提到声明式 UI 开发的威力</a>。</p> <p data-v-48809fbe>声明式编程的潜力在于：</p> <p data-v-48809fbe><strong data-v-48809fbe>解放人力成本，你只要「声明」你要做什么，具体怎么做，由运行时解决。</strong></p> <p data-v-48809fbe>函数式编程就是声明式编程的一种，在函数式编程里的<a rel="noopener noreferrer" target="_blank" href="https://zh.wikipedia.org/zh-hans/%E5%B0%BE%E8%B0%83%E7%94%A8?oldformat=true" data-v-48809fbe>尾递归</a>性能，就取决于运行时，而不是靠程序员去手动优化。React 里你只要描述你的 UI, 接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠程序员优化 diff 算法。</p> <p data-v-48809fbe>我们可以认为 Serverless (尤其是函数计算) 在运维领域获得了声明式的好处 —— 我们定义好了函数，我们只要告诉平台我们需要调用这个函数，那么如何进行计算资源分配、如何对代码做分布式部署，都不需要程序员考虑。</p> <p data-v-48809fbe>运行时帮你完成工作，除了可以节省人力成本外，还降低了程序员出错的概率 —— 因为写的代码越少，出错的概率就越小。人是最不可靠的，我们应该尽量把工作交给计算机。</p> <p data-v-48809fbe><strong data-v-48809fbe>「声明」是「描述」而不是真正「执行」</strong></p> <p data-v-48809fbe>在纯函数式编程语言里面，一切都是声明式的，是纯 (Pure) 的，没有副作用（Side Effect）的。</p> <p data-v-48809fbe>Haskell 是一个纯函数式的语言，像在控制台输出文本这种方法（<code data-v-48809fbe>putStrLn</code>）就是一种副作用。在 Haskell 里 <code data-v-48809fbe>putStrLn &quot;Hello World&quot;</code> 本身不会真正地输出 “Hello World“, 而是返回一个 IO 类型，来说明他是一个副作用。但它如何被执行，取决于运行时。</p> <p data-v-48809fbe><a rel="noopener noreferrer" target="_blank" href="https://elm-lang.org" data-v-48809fbe>Elm</a> 和 Haskell 一样，副作用也只是返回一种类似 Haskell 中的 IO 类型。在 Elm 中叫做 Cmd.</p> <p data-v-48809fbe><img src="https://gbstatic.djyde.com/F5AF0D75-30A2-46DD-B66F-9FDEFFC10B27.png?x-oss-process=style/80" alt="" data-v-48809fbe></p> <p data-v-48809fbe>以上说的这些，可能太过抽象。所以我用前端的同学们应该都知道的 redux-saga 对此作更具象的解释。也可以解答为什么我虽然不喜欢 Redux, 但认为 redux-saga 是一个的很不错的库。因为他利用 redux 的 middleware 机制和 generator 巧妙地实现了类似 Haskell 的 IO.</p> <p data-v-48809fbe>下面我将用 <a rel="noopener noreferrer" target="_blank" href="https://redux-saga.js.org/docs/basics/DeclarativeEffects.html" data-v-48809fbe>官方文档的例子</a> 做解释。</p> <p data-v-48809fbe>比如，以下是一个有副作用的函数:</p> <div class="saber-highlight" data-lang="js" data-v-48809fbe><pre class="saber-highlight-code language-js" data-v-48809fbe><code class="language-js" data-v-48809fbe><span class="token keyword" data-v-48809fbe>import</span> <span class="token punctuation" data-v-48809fbe>{</span> call <span class="token punctuation" data-v-48809fbe>}</span> <span class="token keyword" data-v-48809fbe>from</span> <span class="token string" data-v-48809fbe>'redux-saga/effects'</span>

<span class="token keyword" data-v-48809fbe>function</span><span class="token operator" data-v-48809fbe>*</span> <span class="token function" data-v-48809fbe>fetchProducts</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token punctuation" data-v-48809fbe>)</span> <span class="token punctuation" data-v-48809fbe>{</span>
  <span class="token keyword" data-v-48809fbe>const</span> products <span class="token operator" data-v-48809fbe>=</span> <span class="token keyword" data-v-48809fbe>yield</span> <span class="token function" data-v-48809fbe>call</span><span class="token punctuation" data-v-48809fbe>(</span>Api<span class="token punctuation" data-v-48809fbe>.</span>fetch<span class="token punctuation" data-v-48809fbe>,</span> <span class="token string" data-v-48809fbe>'/products'</span><span class="token punctuation" data-v-48809fbe>)</span>
  <span class="token comment" data-v-48809fbe>// ...</span>
<span class="token punctuation" data-v-48809fbe>}</span></code></pre></div><p data-v-48809fbe>显然，<code data-v-48809fbe>Api.fetch()</code> 是副作用，它会发送网络请求。但是，在 redux-saga 里面，你不应该直接执行这个函数，而是使用 <code data-v-48809fbe>call</code> 告诉 redux-saga —— 你要执行 <code data-v-48809fbe>Api.fetch</code> , 参数为 <code data-v-48809fbe>/products</code>.</p> <p data-v-48809fbe>所以，事实上这个函数没有被命令式地被执行，而是由 redux-saga 决定如何执行。</p> <p data-v-48809fbe>如果你在外部直接调用 <code data-v-48809fbe>fetchProducts()</code>, 你会得到一个 Generator Iterator. 然后通过 <code data-v-48809fbe>next()</code> 得到你 yield 的值。所以你可以这样去测试你的程序：</p> <div class="saber-highlight" data-lang="js" data-v-48809fbe><pre class="saber-highlight-code language-js" data-v-48809fbe><code class="language-js" data-v-48809fbe><span class="token keyword" data-v-48809fbe>const</span> iterator <span class="token operator" data-v-48809fbe>=</span> <span class="token function" data-v-48809fbe>fetchProducts</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token punctuation" data-v-48809fbe>)</span>

<span class="token comment" data-v-48809fbe>// expects a call instruction</span>
assert<span class="token punctuation" data-v-48809fbe>.</span><span class="token function" data-v-48809fbe>deepEqual</span><span class="token punctuation" data-v-48809fbe>(</span>
  iterator<span class="token punctuation" data-v-48809fbe>.</span><span class="token function" data-v-48809fbe>next</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token punctuation" data-v-48809fbe>)</span><span class="token punctuation" data-v-48809fbe>.</span>value<span class="token punctuation" data-v-48809fbe>,</span>
  <span class="token function" data-v-48809fbe>call</span><span class="token punctuation" data-v-48809fbe>(</span>Api<span class="token punctuation" data-v-48809fbe>.</span>fetch<span class="token punctuation" data-v-48809fbe>,</span> <span class="token string" data-v-48809fbe>'/products'</span><span class="token punctuation" data-v-48809fbe>)</span><span class="token punctuation" data-v-48809fbe>,</span>
  <span class="token string" data-v-48809fbe>&quot;fetchProducts should yield an Effect call(Api.fetch, './products')&quot;</span>
<span class="token punctuation" data-v-48809fbe>)</span></code></pre></div><p data-v-48809fbe>也就是说，你要测试的是「你有没有告诉程序你要执行的副作用，以及执行的参数是什么」。和命令式编程不同，因为命令式的程序在你执行函数时会真实地执行这个 <code data-v-48809fbe>Api.fetch</code>，你必须用测试框架里类似 <code data-v-48809fbe>mockFn</code> 的手段去 mock 这个函数进行测试。</p> <p data-v-48809fbe><code data-v-48809fbe>fetchProducts()</code> 只有在 Redux 环境里，才会真正地执行副作用（在这里就是 Api.fetch 发送的网络请求）。</p> <p data-v-48809fbe>所以，<strong data-v-48809fbe>声明式的编程是非常易于测试的</strong>。</p> <p data-v-48809fbe><strong data-v-48809fbe>可视化编程是一种声明式编程</strong></p> <p data-v-48809fbe>我们探索可视化编程，是因为我们一直期望通过拖拽就能完成开发，其实就是期望我们完成任务仅仅需要通过声明，而不是写命令式的代码。当然这是一种理想的状态。</p> <p data-v-48809fbe>DSL 是最常见的声明式编程形式。我一直在布道 GraphQL, 因为它把网络请求变得声明式了：</p> <div class="saber-highlight" data-lang="gql" data-v-48809fbe><pre class="saber-highlight-code language-gql" data-v-48809fbe><code class="language-gql" data-v-48809fbe>query {
	posts {
		id, title, content
  }
}</code></pre></div><p data-v-48809fbe>把网络请求变成声明式的好处有很多，其中一个就是它可以被放到各种各样的环境被执行。想象一下，我们可以打造一个可视化的应用搭建工具，在命令式编程的场景下，我们如果要做出如「点击按钮发送请求，得到响应后触发另一个 UI 更新」，就需要编写命令式的代码：</p> <div class="saber-highlight" data-lang="js" data-v-48809fbe><pre class="saber-highlight-code language-js" data-v-48809fbe><code class="language-js" data-v-48809fbe><span class="token keyword" data-v-48809fbe>async</span> <span class="token keyword" data-v-48809fbe>function</span> <span class="token function" data-v-48809fbe>onClickButton</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token punctuation" data-v-48809fbe>)</span> <span class="token punctuation" data-v-48809fbe>{</span>
	<span class="token comment" data-v-48809fbe>// 手动发送请求</span>
	<span class="token keyword" data-v-48809fbe>const</span> result <span class="token operator" data-v-48809fbe>=</span> <span class="token keyword" data-v-48809fbe>await</span> <span class="token function" data-v-48809fbe>fetch</span><span class="token punctuation" data-v-48809fbe>(</span><span class="token string" data-v-48809fbe>'/api'</span><span class="token punctuation" data-v-48809fbe>)</span>
	<span class="token comment" data-v-48809fbe>// 手动更新 UI</span>
  table<span class="token punctuation" data-v-48809fbe>.</span>dataSource <span class="token operator" data-v-48809fbe>=</span> result
<span class="token punctuation" data-v-48809fbe>}</span></code></pre></div><p data-v-48809fbe>如果是 GraphQL, 我们可以把每一条 GraphQL 语句单独看作一个对象，他可以被任何组件触发，它的结果也可以被任何组件订阅。这样一来，在可视化的搭建工具里，程序员要做的是：</p> <ol data-v-48809fbe><li data-v-48809fbe>（声明式地）编写 GraphQL 查询语句</li> <li data-v-48809fbe>（声明式地）为组件（比如某个按钮）绑定 onClick 事件为触发某条查询语句</li> <li data-v-48809fbe>（声明式地）为组件（比如某个表格）绑定某条查询语句的响应值对应哪些组件的属性值</li></ol> <p data-v-48809fbe>当然现实世界的应用不是那么简单，但已经是跨出了很大一步。</p> <h2 id="conclusion" data-v-48809fbe>Conclusion</h2> <p data-v-48809fbe>未来为什么属于声明式编程，因为我们在不断地努力提高开发效率，声明式编程显然是提效的最佳手段。React, Flutter, SwiftUI, GraphQL 的出现是最好的证明。最近听到内网太多人在提 Serverless, 我想说，<strong data-v-48809fbe>提升开发效率，我们应该去想如何尽量让开发者声明式地编写代码，而不是只去想我们在 Serverless 上能做什么。</strong></p></div> <div class="post-footer" data-v-48809fbe><hr data-v-48809fbe> <p data-v-48809fbe>讨论请发邮件到 randypriv@gmail.com</p> <p data-v-48809fbe>未经授权，禁止转载</p> <p data-v-48809fbe>通过支付宝 djyde520@gmail.com 或赞赏码赞助此文</p> <p data-v-48809fbe>
        或通过订阅我的
        <a href="/blog/my-zsxq/" data-v-48809fbe data-v-48809fbe>知识星球</a>支持本博客
      </p> <br data-v-48809fbe> <p data-v-48809fbe><img src="//gbstatic.djyde.com/assets/006tKfTcgy1fkuufy2cadj30w00w0tb2.jpg" class="bmc" data-v-48809fbe></p></div></div></div> <div id="footer"><p><img width="256px" src="//s2.ax1x.com/2019/04/04/A2V9YT.png"></p> <p>
      2014-2019
      <a href="/" class="router-link-active">Randy's Blog</a></p></div></div></div><script src="/_saber/js/client.29710ed1.js" defer></script><script src="/_saber/js/page--_posts-declarative-programming-is-the-future-md.dd22f9a3.js" defer></script></body></html>
